use std::collections::HashMap;
use std::io::{self, Cursor, Error, ErrorKind, Read, Seek, SeekFrom};

#[derive(Debug)]
pub struct Source<T> {
    name: String,
    size: u64,
    source: T,
}

impl<T> Read for Source<T>
where
    T: Read + Seek,
{
    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        self.source.read(buf)
    }
}

impl<T> Seek for Source<T>
where
    T: Read + Seek,
{
    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {
        self.source.seek(pos)
    }
}

#[derive(Debug)]
pub struct Reader<T> {
    // file ids in the order they should be returned
    index: Vec<(u64, u64)>,
    // total length
    len: u64,
    // where are we within the index if this tar actually existed already
    pos: u64,
    // map file names to an id, this cuts down on memory usage when a tar has a
    // bunch of references to the same file (which is specifically why I wrote
    // this library lol)
    rolodex: HashMap<String, u64>,
    rolodex_next: u64,
    // map of file IDs to their underlying ReadSeeks
    sources: HashMap<u64, Source<T>>,
}

impl<T> Reader<T>
where
    T: Read + Seek,
{
    pub fn new() -> Reader<T> {
        Reader {
            index: Vec::new(),
            len: 0,
            pos: 0,
            rolodex: HashMap::new(),
            rolodex_next: 0,
            sources: HashMap::new(),
        }
    }

    // TODO: should we lock appends after the first read? Or maybe only when a
    //       read goes into the trailing blocks? Also:
    // TODO: implement trailing blocks
    pub fn append_entry(&mut self, name: String, mut source: T) {
        // create a rolodex entry if needed
        let id = if self.rolodex.contains_key(&name) {
            self.rolodex
                .get(&name)
                .expect("rolodex has entry but not a value?")
                .clone()
        } else {
            let i = self.rolodex_next;
            self.rolodex_next += 1;
            self.rolodex.insert(name.clone(), i);
            i
        };

        // create a sources entry if needed
        if !self.sources.contains_key(&id) {
            let size = source
                .seek(SeekFrom::End(0))
                .expect("Couldn't get length of source");
            source
                .seek(SeekFrom::Start(0))
                .expect("Couldn't rewind source");

            self.sources.insert(
                id,
                Source {
                    name: name.clone(),
                    size,
                    source,
                },
            );
        }

        let size = self.sources.get(&id).expect("How did we get here?").size;
        // append another copy of this source to the output
        self.index.push((id, self.len));
        self.len += 512 + size;
    }

    fn header(&mut self, id: u64) -> [u8; 512] {
        // chksum is initialized to spaces per:
        // https://www.gnu.org/software/tar/manual/html_node/Standard.html
        let mut buf = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, // name
            0x30, 0x30, 0x30, 0x30, 0x36, 0x36, 0x34, 0x00, // mode
            0x30, 0x30, 0x30, 0x31, 0x37, 0x35, 0x30, 0x00, // uid
            0x30, 0x30, 0x30, 0x31, 0x37, 0x35, 0x30, 0x00, // gid
            0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00, // size
            0x31, 0x34, 0x36, 0x32, 0x33, 0x32, 0x36, 0x30, 0x35, 0x33, 0x31, 0x00, // mtime
            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, // chksum
            0x30, // typeflag
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, // linkname
            0x75, 0x73, 0x74, 0x61, 0x72, 0x20, // magic
            0x20, 0x00, // version
            0x6c, 0x69, 0x61, 0x74, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, // uname
            0x6c, 0x69, 0x61, 0x74, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, // gname
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // devmajor
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // devminor
            // prefix ->
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        let f = self.sources.get(&id).expect("failed to retrieve source");
        for (i, c) in f.name.chars().enumerate() {
            if i == 100 {
                break;
            }

            buf[i] = c as u8;
        }

        let size = format!("{:0>11o}", f.size);
        println!("size: {}", size);
        for (i, c) in size.chars().enumerate() {
            buf[124 + i] = c as u8;
        }

        let chksum = format!("{:0>6o}", buf.iter().fold(0u64, |sum, i| sum + (*i as u64)));
        println!("chksum: {}", chksum);
        for (i, c) in chksum.chars().enumerate() {
            buf[148 + i] = c as u8;
        }
        buf[154] = 0;

        buf
    }

    fn index_to_source_offset(&mut self, at: u64) -> (u64, u64) {
        for (id, offset) in self.index.iter() {
            if *offset >= at {
                return (*id, at - offset);
            }
        }
        unreachable!("Ain't nobody here but us chickens");
    }
}

impl<T> Read for Reader<T>
where
    T: Read + Seek,
{
    // NOTE: we dont need to generate the next header as we cross file
    //       boundaries, return what you've got and how many bytes you read and
    //       the Read implementation will make another request where we'll
    //       start nicely at the next file header
    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        let (id, offset) = self.index_to_source_offset(self.pos);
        if offset > 512 {
            let source = self.sources.get_mut(&id).expect("Unable to fetch source");
            source
                .seek(SeekFrom::Start(offset - 512))
                .expect("Unable to seek source");
            let res = source.read(buf).expect("Failed to read source");
            self.pos += res as u64;
            return Ok(res);
        }

        let mut header = Cursor::new(self.header(id));
        header
            .seek(SeekFrom::Start(offset))
            .expect("Somehow failed to seek header, but whhhhyyyy?");
        let res = header
            .read(buf)
            .expect("Somehow failed to read header, how could that even happen???");
        self.pos += res as u64;
        return Ok(res);
    }
}

impl<T> Seek for Reader<T>
where
    T: Read + Seek,
{
    fn seek(&mut self, style: SeekFrom) -> io::Result<u64> {
        let (base_pos, offset) = match style {
            SeekFrom::Start(n) => {
                self.pos = n;
                return Ok(n);
            }
            SeekFrom::End(n) => (self.len, n),
            SeekFrom::Current(n) => (self.pos, n),
        };
        match base_pos.checked_add_signed(offset) {
            Some(n) => {
                self.pos = n;
                Ok(self.pos)
            }
            None => Err(Error::new(
                ErrorKind::InvalidInput,
                "invalid seek to a negative or overflowing position",
            )),
        }
    }
}

#[cfg(test)]
mod tests;
